# Continuous Integration tests
name: NUbots CI

# Controls when the action will run.
on:
  # Triggers on PRs to any branch
  pull_request:

# Only a single workflow will run at a time.
concurrency:
  # A unique key to determine the workflow's group membership.
  group: ${{ github.workflow }}-${{ github.ref }}
  # Any workflows already running in the group will be cancelled.
  cancel-in-progress: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # Declare a new job.
  build_llvm:
    name: "Build LLVM"
    # Run the reusable workflow.
    uses: ./.github/workflows/build_part_of_image.yaml

    # Declare inputs for reusable workflow.
    with:
      # Specify which stage in the Dockerfile is being built (i.e. `FROM ... AS ...`)
      target: llvm
      # Use the following images as caches from hub.docker.com.
      cache_from: |
        type=registry,ref=nubots/nubots:pull-request-${{ github.event.number }}-llvm
        type=registry,ref=nubots/nubots:generic
        type=inline
    secrets:
      docker_hub_username: ${{ secrets.DOCKERHUB_USERNAME }}
      docker_hub_password: ${{ secrets.DOCKERHUB_PASSWORD }}

  # Declare another job.
  build_intel_graphics_compiler_and_compute_runtime:
    name: "Build Intel Graphics Compiler and Compute Runtime"
    # Run the reusable workflow.
    uses: ./.github/workflows/build_part_of_image.yaml
    # Wait for the following jobs to complete.
    needs: build_llvm
    # Declare inputs for the reusable workflow.
    with:
      target: intel-graphics-compiler-and-compute-runtime
      # Use the following images as caches from hub.docker.com. Notice how llvm is also listed.
      cache_from: |
        type=registry,ref=nubots/nubots:pull-request-${{ github.event.number }}-llvm
        type=registry,ref=nubots/nubots:pull-request-${{ github.event.number }}-intel-graphics-compiler-and-compute-runtime
        type=registry,ref=nubots/nubots:generic
        type=inline
    secrets:
      docker_hub_username: ${{ secrets.DOCKERHUB_USERNAME }}
      docker_hub_password: ${{ secrets.DOCKERHUB_PASSWORD }}

  build_openblas:
    name: "Build OpenBLAS"
    uses: ./.github/workflows/build_part_of_image.yaml
    with:
      target: openblas
      cache_from: |
        type=registry,ref=nubots/nubots:pull-request-${{ github.event.number }}-openblas
        type=registry,ref=nubots/nubots:generic
        type=inline
    secrets:
      docker_hub_username: ${{ secrets.DOCKERHUB_USERNAME }}
      docker_hub_password: ${{ secrets.DOCKERHUB_PASSWORD }}

  build_other_dependencies:
    name: "Build Other Dependencies"
    uses: ./.github/workflows/build_part_of_image.yaml
    with:
      target: other-dependencies
      cache_from: |
        type=registry,ref=nubots/nubots:pull-request-${{ github.event.number }}-other-dependencies
        type=registry,ref=nubots/nubots:generic
        type=inline
    secrets:
      docker_hub_username: ${{ secrets.DOCKERHUB_USERNAME }}
      docker_hub_password: ${{ secrets.DOCKERHUB_PASSWORD }}

  # Build the docker image.
  build_docker:
    name: "Build docker image"
    uses: ./.github/workflows/build_part_of_image.yaml
    # Wait for previous jobs to finish before building the final image.
    needs:
      - build_llvm
      - build_intel_graphics_compiler_and_compute_runtime
      - build_openblas
      - build_other_dependencies
    with:
      # Build the final-image stage.
      target: final-image
      # Use the following images as caches from hub.docker.com.
      cache_from: |
        type=registry,ref=nubots/nubots:pull-request-${{ github.event.number }}-intel-graphics-compiler-and-compute-runtime
        type=registry,ref=nubots/nubots:pull-request-${{ github.event.number }}-llvm
        type=registry,ref=nubots/nubots:pull-request-${{ github.event.number }}-openblas
        type=registry,ref=nubots/nubots:pull-request-${{ github.event.number }}-other-dependencies
        type=registry,ref=nubots/nubots:pull-request-${{ github.event.number }}-final-image
        type=registry,ref=nubots/nubots:generic
        type=inline
    secrets:
      docker_hub_username: ${{ secrets.DOCKERHUB_USERNAME }}
      docker_hub_password: ${{ secrets.DOCKERHUB_PASSWORD }}

  # Add a no-op so pull request checks pass.
  # For some reason, pull request checks do not detect the previous job with
  # the same name, most likely because it calls a reusable workflow.
  build_docker_image:
    name: "Build docker image"
    runs-on: ubuntu-20.04
    steps:
      - run: echo 'Already complete step.'

  # Build the codebase
  build_nubots:
    name: "Build and test NUbots"

    # The type of runner that the job will run on
    runs-on: ubuntu-20.04

    # Wait until the image is built.
    needs: build_docker

    # Run on the container we just built
    container:
      image: nubots/nubots:pull-request-${{ github.event.number }}-final-image
      options: --user 0:0

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Checkout Code
        uses: actions/checkout@v2

      - name: Prepare Build Directory
        run: mkdir -p ../build

      - name: Configure the code
        run: ./b configure -- -DBUILD_TESTS=ON -DCI_BUILD=ON

      - name: Build the code
        run: ./b build

      - name: Test the code
        run: ./b tests run

  # Check the code is formatted according to clang-format
  clang-format:
    name: "C++/Protobuf Formatting"
    # The type of runner that the job will run on
    runs-on: ubuntu-20.04
    needs: build_docker

    # Run on the container we just built
    container:
      image: nubots/nubots:pull-request-${{ github.event.number }}-final-image
      options: --user 0:0

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Checkout Code
        uses: actions/checkout@v2

      - name: Check clang-format
        run: .github/workflows/scripts/validate_clang_format.sh

  # Validate the formatting is correct according to cmake-format
  cmake-format:
    name: "CMake Formatting"
    # The type of runner that the job will run on
    runs-on: ubuntu-20.04
    needs: build_docker

    # Run on the container we just built
    container:
      image: nubots/nubots:pull-request-${{ github.event.number }}-final-image
      options: --user 0:0

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Checkout Code
        uses: actions/checkout@v2

      - name: Check cmake-format
        run: .github/workflows/scripts/validate_cmake_format.sh

  # Validate the formatting is correct according to isort and black
  python-format:
    name: "Python Formatting"
    # The type of runner that the job will run on
    runs-on: ubuntu-20.04
    needs: build_docker

    # Run on the container we just built
    container:
      image: nubots/nubots:pull-request-${{ github.event.number }}-final-image
      options: --user 0:0

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Checkout Code
        uses: actions/checkout@v2

      - name: Check isort and black
        run: .github/workflows/scripts/validate_python_format.sh
