<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NUbots: module::extension::Director Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--START doxygen_awesome-->
<script type="text/javascript" src="styles/doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<!--END doxygen_awesome-->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<a href="https://github.com/NUbots/NUbots" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="banner.png"/></td>
  <td id="projectalign">
   <div id="projectname">NUbots
   </div>
   <div id="projectbrief">NUbots Main Codebase</div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classmodule_1_1extension_1_1Director.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmodule_1_1extension_1_1Director-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">module::extension::Director Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for module::extension::Director:</div>
<div class="dyncontent">
<div class="center"><img src="classmodule_1_1extension_1_1Director__inherit__graph.png" border="0" usemap="#module_1_1extension_1_1Director_inherit__map" alt="Inheritance graph"/></div>
<map name="module_1_1extension_1_1Director_inherit__map" id="module_1_1extension_1_1Director_inherit__map">
<area shape="rect" title=" " alt="" coords="54,95,205,136"/>
<area shape="rect" title=" " alt="" coords="5,13,77,39"/>
<area shape="rect" href="classextension_1_1behaviour_1_1information_1_1InformationSource.html" title="This class is an abstract class that allows the static Behaviour DSL to access the relevant state fro..." alt="" coords="101,5,336,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for module::extension::Director:</div>
<div class="dyncontent">
<div class="center"><img src="classmodule_1_1extension_1_1Director__coll__graph.png" border="0" usemap="#module_1_1extension_1_1Director_coll__map" alt="Collaboration graph"/></div>
<map name="module_1_1extension_1_1Director_coll__map" id="module_1_1extension_1_1Director_coll__map">
<area shape="rect" title=" " alt="" coords="18,96,169,137"/>
<area shape="rect" title=" " alt="" coords="5,13,77,39"/>
<area shape="rect" href="classextension_1_1behaviour_1_1information_1_1InformationSource.html" title="This class is an abstract class that allows the static Behaviour DSL to access the relevant state fro..." alt="" coords="101,5,336,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Solution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object which holds the possible solutions to running a task.  <a href="structmodule_1_1extension_1_1Director_1_1Solution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa561a54be7b26deba7eb5279ca2c10f0"><td class="memItemLeft" align="right" valign="top"><a id="aa561a54be7b26deba7eb5279ca2c10f0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#aa561a54be7b26deba7eb5279ca2c10f0">TaskPack</a> = std::vector&lt; std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &gt;</td></tr>
<tr class="memdesc:aa561a54be7b26deba7eb5279ca2c10f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A task pack is the result of a set of tasks emitted by a provider that should be run together. <br /></td></tr>
<tr class="separator:aa561a54be7b26deba7eb5279ca2c10f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb1ec9a84837de372581b6324ca9317"><td class="memItemLeft" align="right" valign="top"><a id="aabb1ec9a84837de372581b6324ca9317"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#aabb1ec9a84837de372581b6324ca9317">TaskQueue</a> = std::vector&lt; std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &gt;</td></tr>
<tr class="memdesc:aabb1ec9a84837de372581b6324ca9317"><td class="mdescLeft">&#160;</td><td class="mdescRight">A task queue holds tasks in a provider that are waiting to be executed by that group. <br /></td></tr>
<tr class="separator:aabb1ec9a84837de372581b6324ca9317"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab5586dc9feb7878dd9a6a6234088d8a3"><td class="memItemLeft" align="right" valign="top"><a id="ab5586dc9feb7878dd9a6a6234088d8a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#ab5586dc9feb7878dd9a6a6234088d8a3">Director</a> (std::unique_ptr&lt; NUClear::Environment &gt; environment)</td></tr>
<tr class="memdesc:ab5586dc9feb7878dd9a6a6234088d8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the powerplant to build and setup the <a class="el" href="classmodule_1_1extension_1_1Director.html">Director</a> reactor. <br /></td></tr>
<tr class="separator:ab5586dc9feb7878dd9a6a6234088d8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75deae1643268535343886608a697ea"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#ac75deae1643268535343886608a697ea">_get_task_data</a> (const uint64_t &amp;reaction_id) override</td></tr>
<tr class="memdesc:ac75deae1643268535343886608a697ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the task data via the InformationSource interface so it can be accessed.  <a href="classmodule_1_1extension_1_1Director.html#ac75deae1643268535343886608a697ea">More...</a><br /></td></tr>
<tr class="separator:ac75deae1643268535343886608a697ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae38a0f87a58faec7521d61eb4faaae7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#ae38a0f87a58faec7521d61eb4faaae7a">add_causing</a> (const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1CausingExpression.html">extension::behaviour::commands::CausingExpression</a> &amp;causing)</td></tr>
<tr class="memdesc:ae38a0f87a58faec7521d61eb4faaae7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a causing condition to an existing Provider.  <a href="classmodule_1_1extension_1_1Director.html#ae38a0f87a58faec7521d61eb4faaae7a">More...</a><br /></td></tr>
<tr class="separator:ae38a0f87a58faec7521d61eb4faaae7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa959f154ca485d8bb435b898ecb3223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#aaa959f154ca485d8bb435b898ecb3223">add_needs</a> (const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1NeedsExpression.html">extension::behaviour::commands::NeedsExpression</a> &amp;needs)</td></tr>
<tr class="memdesc:aaa959f154ca485d8bb435b898ecb3223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a needs to an existing Provider.  <a href="classmodule_1_1extension_1_1Director.html#aaa959f154ca485d8bb435b898ecb3223">More...</a><br /></td></tr>
<tr class="separator:aaa959f154ca485d8bb435b898ecb3223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194487bb54ff0df9fb6dfd687b8f80f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a194487bb54ff0df9fb6dfd687b8f80f6">add_provider</a> (const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1ProvideReaction.html">extension::behaviour::commands::ProvideReaction</a> &amp;provide)</td></tr>
<tr class="memdesc:a194487bb54ff0df9fb6dfd687b8f80f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a Provider for a type.  <a href="classmodule_1_1extension_1_1Director.html#a194487bb54ff0df9fb6dfd687b8f80f6">More...</a><br /></td></tr>
<tr class="separator:a194487bb54ff0df9fb6dfd687b8f80f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5fe71a8de8e8282b0a2774e6249e43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a0f5fe71a8de8e8282b0a2774e6249e43">add_when</a> (const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1WhenExpression.html">extension::behaviour::commands::WhenExpression</a> &amp;when)</td></tr>
<tr class="memdesc:a0f5fe71a8de8e8282b0a2774e6249e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a when condition to an existing Provider.  <a href="classmodule_1_1extension_1_1Director.html#a0f5fe71a8de8e8282b0a2774e6249e43">More...</a><br /></td></tr>
<tr class="separator:a0f5fe71a8de8e8282b0a2774e6249e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7a7fa469161951a33a871e7c8e4fae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#aee7a7fa469161951a33a871e7c8e4fae">challenge_priority</a> (const std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &amp;incumbent, const std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &amp;challenger)</td></tr>
<tr class="memdesc:aee7a7fa469161951a33a871e7c8e4fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the priorities of two director tasks and returns true if the challenger has priority over the incumbent.  <a href="classmodule_1_1extension_1_1Director.html#aee7a7fa469161951a33a871e7c8e4fae">More...</a><br /></td></tr>
<tr class="separator:aee7a7fa469161951a33a871e7c8e4fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da8ac4a61e4cf0a9fc70b7339de88da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a8da8ac4a61e4cf0a9fc70b7339de88da">reevaluate_queue</a> (<a class="el" href="structmodule_1_1extension_1_1provider_1_1ProviderGroup.html">provider::ProviderGroup</a> &amp;group)</td></tr>
<tr class="memdesc:a8da8ac4a61e4cf0a9fc70b7339de88da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reevaluates all of the tasks that are queued to execute on a provider group.  <a href="classmodule_1_1extension_1_1Director.html#a8da8ac4a61e4cf0a9fc70b7339de88da">More...</a><br /></td></tr>
<tr class="separator:a8da8ac4a61e4cf0a9fc70b7339de88da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71aac2110faf4406b7c01b2eeeb79e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#ac71aac2110faf4406b7c01b2eeeb79e6">remove_provider</a> (const uint64_t &amp;id)</td></tr>
<tr class="memdesc:ac71aac2110faf4406b7c01b2eeeb79e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a Provider for a type.  <a href="classmodule_1_1extension_1_1Director.html#ac71aac2110faf4406b7c01b2eeeb79e6">More...</a><br /></td></tr>
<tr class="separator:ac71aac2110faf4406b7c01b2eeeb79e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98334de2bbb98c327e0a09108784541"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#ac98334de2bbb98c327e0a09108784541">remove_task</a> (const std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &amp;task)</td></tr>
<tr class="memdesc:ac98334de2bbb98c327e0a09108784541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the provided task from the <a class="el" href="classmodule_1_1extension_1_1Director.html">Director</a>.  <a href="classmodule_1_1extension_1_1Director.html#ac98334de2bbb98c327e0a09108784541">More...</a><br /></td></tr>
<tr class="separator:ac98334de2bbb98c327e0a09108784541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867e019bba1e28cf210a89d786452bf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a867e019bba1e28cf210a89d786452bf5">run_task_pack</a> (const <a class="el" href="classmodule_1_1extension_1_1Director.html#aa561a54be7b26deba7eb5279ca2c10f0">TaskPack</a> &amp;pack)</td></tr>
<tr class="memdesc:a867e019bba1e28cf210a89d786452bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks at all the tasks that are in the pack and determines if they should run, and if so runs them.  <a href="classmodule_1_1extension_1_1Director.html#a867e019bba1e28cf210a89d786452bf5">More...</a><br /></td></tr>
<tr class="separator:a867e019bba1e28cf210a89d786452bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8886c4242eb05b44c156c6a3ecc6a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#ad8886c4242eb05b44c156c6a3ecc6a6b">solve_group</a> (const std::type_index &amp;type, const std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &amp;authority, const std::set&lt; std::shared_ptr&lt; const <a class="el" href="structmodule_1_1extension_1_1provider_1_1Provider.html">provider::Provider</a> &gt;&gt; &amp;visited)</td></tr>
<tr class="memdesc:ad8886c4242eb05b44c156c6a3ecc6a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates options for each provider in a provider group specified by the passed type.  <a href="classmodule_1_1extension_1_1Director.html#ad8886c4242eb05b44c156c6a3ecc6a6b">More...</a><br /></td></tr>
<tr class="separator:ad8886c4242eb05b44c156c6a3ecc6a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d65a6d37112d4b1a8bcb930780b656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution_1_1Option.html">Solution::Option</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#af1d65a6d37112d4b1a8bcb930780b656">solve_provider</a> (const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1provider_1_1Provider.html">provider::Provider</a> &gt; &amp;provider, const std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &amp;authority, std::set&lt; std::shared_ptr&lt; const <a class="el" href="structmodule_1_1extension_1_1provider_1_1Provider.html">provider::Provider</a> &gt;&gt; visited)</td></tr>
<tr class="memdesc:af1d65a6d37112d4b1a8bcb930780b656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the passed provider as an option for a solution along with its requirements.  <a href="classmodule_1_1extension_1_1Director.html#af1d65a6d37112d4b1a8bcb930780b656">More...</a><br /></td></tr>
<tr class="separator:af1d65a6d37112d4b1a8bcb930780b656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b5c76a054ee519a189085c85a4a4c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a36b5c76a054ee519a189085c85a4a4c8">solve_task</a> (const std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &amp;task)</td></tr>
<tr class="memdesc:a36b5c76a054ee519a189085c85a4a4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a solution for a given task.  <a href="classmodule_1_1extension_1_1Director.html#a36b5c76a054ee519a189085c85a4a4c8">More...</a><br /></td></tr>
<tr class="separator:a36b5c76a054ee519a189085c85a4a4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92552817ea426f29109e51e468c951c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a92552817ea426f29109e51e468c951c7">solve_when</a> (const <a class="el" href="structmodule_1_1extension_1_1provider_1_1Provider_1_1WhenCondition.html">provider::Provider::WhenCondition</a> &amp;when, const std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &amp;authority, const std::set&lt; std::shared_ptr&lt; const <a class="el" href="structmodule_1_1extension_1_1provider_1_1Provider.html">provider::Provider</a> &gt;&gt; &amp;visited)</td></tr>
<tr class="memdesc:a92552817ea426f29109e51e468c951c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the providers that can cause the passed when condition to be met.  <a href="classmodule_1_1extension_1_1Director.html#a92552817ea426f29109e51e468c951c7">More...</a><br /></td></tr>
<tr class="separator:a92552817ea426f29109e51e468c951c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5229764df175d487be239513c912bdf1"><td class="memItemLeft" align="right" valign="top"><a id="a5229764df175d487be239513c912bdf1"></a>
std::map&lt; std::type_index, <a class="el" href="structmodule_1_1extension_1_1provider_1_1ProviderGroup.html">provider::ProviderGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a5229764df175d487be239513c912bdf1">groups</a></td></tr>
<tr class="memdesc:a5229764df175d487be239513c912bdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of Provider groups. <br /></td></tr>
<tr class="separator:a5229764df175d487be239513c912bdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680f053fbda9f7f0f8684e15ad8b455a"><td class="memItemLeft" align="right" valign="top"><a id="a680f053fbda9f7f0f8684e15ad8b455a"></a>
std::multimap&lt; uint64_t, std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a680f053fbda9f7f0f8684e15ad8b455a">pack_builder</a></td></tr>
<tr class="memdesc:a680f053fbda9f7f0f8684e15ad8b455a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of reaction_task_ids to director_task objects, once the Provider has finished running it will emit all these as a pack so that the director can work out when Providers change which subtasks they emit. <br /></td></tr>
<tr class="separator:a680f053fbda9f7f0f8684e15ad8b455a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420ddbdc1d8df6ce35e6c938e760fae4"><td class="memItemLeft" align="right" valign="top"><a id="a420ddbdc1d8df6ce35e6c938e760fae4"></a>
std::map&lt; uint64_t, std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1provider_1_1Provider.html">provider::Provider</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a420ddbdc1d8df6ce35e6c938e760fae4">providers</a></td></tr>
<tr class="memdesc:a420ddbdc1d8df6ce35e6c938e760fae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps reaction_id to the Provider which implements it. <br /></td></tr>
<tr class="separator:a420ddbdc1d8df6ce35e6c938e760fae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8bb1cbbac1238620c272ee22344093e9"><td class="memItemLeft" align="right" valign="top"><a id="a8bb1cbbac1238620c272ee22344093e9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>InformationSource</b></td></tr>
<tr class="separator:a8bb1cbbac1238620c272ee22344093e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classextension_1_1behaviour_1_1information_1_1InformationSource"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classextension_1_1behaviour_1_1information_1_1InformationSource')"><img src="closed.png" alt="-"/>&#160;Static Private Member Functions inherited from <a class="el" href="classextension_1_1behaviour_1_1information_1_1InformationSource.html">extension::behaviour::information::InformationSource</a></td></tr>
<tr class="memitem:ade48b09cd7c578384ed21137d17ad453 inherit pub_static_methods_classextension_1_1behaviour_1_1information_1_1InformationSource"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classextension_1_1behaviour_1_1information_1_1InformationSource.html#ade48b09cd7c578384ed21137d17ad453">get_task_data</a> (const uint64_t &amp;reaction_id)</td></tr>
<tr class="memdesc:ade48b09cd7c578384ed21137d17ad453 inherit pub_static_methods_classextension_1_1behaviour_1_1information_1_1InformationSource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method that redirects to the singleton instance providing the <a class="el" href="classextension_1_1behaviour_1_1information_1_1InformationSource.html" title="This class is an abstract class that allows the static Behaviour DSL to access the relevant state fro...">InformationSource</a>.  <a href="classextension_1_1behaviour_1_1information_1_1InformationSource.html#ade48b09cd7c578384ed21137d17ad453">More...</a><br /></td></tr>
<tr class="separator:ade48b09cd7c578384ed21137d17ad453 inherit pub_static_methods_classextension_1_1behaviour_1_1information_1_1InformationSource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classextension_1_1behaviour_1_1information_1_1InformationSource"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classextension_1_1behaviour_1_1information_1_1InformationSource')"><img src="closed.png" alt="-"/>&#160;Static Private Attributes inherited from <a class="el" href="classextension_1_1behaviour_1_1information_1_1InformationSource.html">extension::behaviour::information::InformationSource</a></td></tr>
<tr class="memitem:ad1978e857d2131c1fc57e5b9ff896028 inherit pub_static_attribs_classextension_1_1behaviour_1_1information_1_1InformationSource"><td class="memItemLeft" align="right" valign="top"><a id="ad1978e857d2131c1fc57e5b9ff896028"></a>
static <a class="el" href="classextension_1_1behaviour_1_1information_1_1InformationSource.html">InformationSource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classextension_1_1behaviour_1_1information_1_1InformationSource.html#ad1978e857d2131c1fc57e5b9ff896028">source</a> = nullptr</td></tr>
<tr class="memdesc:ad1978e857d2131c1fc57e5b9ff896028 inherit pub_static_attribs_classextension_1_1behaviour_1_1information_1_1InformationSource"><td class="mdescLeft">&#160;</td><td class="mdescRight">This static variable gets set by whatever class is acting as the information source. <br /></td></tr>
<tr class="separator:ad1978e857d2131c1fc57e5b9ff896028 inherit pub_static_attribs_classextension_1_1behaviour_1_1information_1_1InformationSource"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac75deae1643268535343886608a697ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75deae1643268535343886608a697ea">&#9670;&nbsp;</a></span>_get_task_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; void &gt; module::extension::Director::_get_task_data </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>reaction_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the task data via the InformationSource interface so it can be accessed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reaction_id</td><td>the provider reaction that is requesting its information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the data that is stored in this reaction, or nullptr if it shouldn't be executing </dd></dl>

<p>Implements <a class="el" href="classextension_1_1behaviour_1_1information_1_1InformationSource.html#a58c78909ce4539d686ca4eee8318760b">extension::behaviour::information::InformationSource</a>.</p>

</div>
</div>
<a id="ae38a0f87a58faec7521d61eb4faaae7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38a0f87a58faec7521d61eb4faaae7a">&#9670;&nbsp;</a></span>add_causing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::add_causing </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1CausingExpression.html">extension::behaviour::commands::CausingExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>causing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a causing condition to an existing Provider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">causing</td><td>the description of the Causing expression from the behaviour extension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa959f154ca485d8bb435b898ecb3223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa959f154ca485d8bb435b898ecb3223">&#9670;&nbsp;</a></span>add_needs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::add_needs </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1NeedsExpression.html">extension::behaviour::commands::NeedsExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>needs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a needs to an existing Provider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needs</td><td>the description of the Needs expression from the behaviour extension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a194487bb54ff0df9fb6dfd687b8f80f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194487bb54ff0df9fb6dfd687b8f80f6">&#9670;&nbsp;</a></span>add_provider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::add_provider </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1ProvideReaction.html">extension::behaviour::commands::ProvideReaction</a> &amp;&#160;</td>
          <td class="paramname"><em>provide</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a Provider for a type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the ProvideReaction object that was generated by the Behaviour extension</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>when there is more than one Provide in an on statement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f5fe71a8de8e8282b0a2774e6249e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5fe71a8de8e8282b0a2774e6249e43">&#9670;&nbsp;</a></span>add_when()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::add_when </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1WhenExpression.html">extension::behaviour::commands::WhenExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>when</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a when condition to an existing Provider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">when</td><td>the description of the When expression from the Behaviour extension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee7a7fa469161951a33a871e7c8e4fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7a7fa469161951a33a871e7c8e4fae">&#9670;&nbsp;</a></span>challenge_priority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool module::extension::Director::challenge_priority </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>incumbent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>challenger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the priorities of two director tasks and returns true if the challenger has priority over the incumbent. </p>
<p>The function requires that the challenger's precedence is strictly greater than the incumbent's. This ensures that we don't change tasks unnecessarily when the priority is equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incumbent</td><td>the task to compare which is currently the active running task </td></tr>
    <tr><td class="paramname">challenger</td><td>the task to compare which wants to run but is not currently running</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the challenger has strictly higher priority than the incumbent </dd>
<dd>
false if the incumbent task has equal or higher priority</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the director's provider ancestry is broken </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8da8ac4a61e4cf0a9fc70b7339de88da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da8ac4a61e4cf0a9fc70b7339de88da">&#9670;&nbsp;</a></span>reevaluate_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::reevaluate_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmodule_1_1extension_1_1provider_1_1ProviderGroup.html">provider::ProviderGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reevaluates all of the tasks that are queued to execute on a provider group. </p>
<p>Each of the tasks in the queue are waiting to use this provider group but cannot for some reason or another. In order to determine if they can now run on the queue we need to look at each queued task and inspect if the provider that created them can now run. We do this by simply trying to run them all again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group whose queue we want to reevaluate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac71aac2110faf4406b7c01b2eeeb79e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71aac2110faf4406b7c01b2eeeb79e6">&#9670;&nbsp;</a></span>remove_provider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::remove_provider </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a Provider for a type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the id of the reaction we want to remove the Provider for</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>when the reaction does not provide anything </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac98334de2bbb98c327e0a09108784541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98334de2bbb98c327e0a09108784541">&#9670;&nbsp;</a></span>remove_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::remove_task </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the provided task from the <a class="el" href="classmodule_1_1extension_1_1Director.html">Director</a>. </p>
<p>This function also deals with all the consequences of removing the task including looking to see if a queued task can now be run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task to remove from the <a class="el" href="classmodule_1_1extension_1_1Director.html">Director</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a867e019bba1e28cf210a89d786452bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867e019bba1e28cf210a89d786452bf5">&#9670;&nbsp;</a></span>run_task_pack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::run_task_pack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmodule_1_1extension_1_1Director.html#aa561a54be7b26deba7eb5279ca2c10f0">TaskPack</a> &amp;&#160;</td>
          <td class="paramname"><em>pack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Looks at all the tasks that are in the pack and determines if they should run, and if so runs them. </p>
<p>This function will ensure that if this pack is to be executed it can be executed as a whole. That means that all of the non optional tasks in it are able to run now given the state of the system. If the system is unable to run due to priority or due to a when condition not met it will not run any of the tasks in this pack, but enqueue them on the relevant providers.</p>
<p>In the event that <code>When</code> conditions needs to be met by this pack and it has sufficient priority, it may also place this provider group into a "Pushing" state whereby it forces another provider group into a state where it will make the system reach the causing it requires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pack</td><td>the task pack that represents the queued tasks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8886c4242eb05b44c156c6a3ecc6a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8886c4242eb05b44c156c6a3ecc6a6b">&#9670;&nbsp;</a></span>solve_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Director::Solution</a> module::extension::Director::solve_group </td>
          <td>(</td>
          <td class="paramtype">const std::type_index &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>authority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::shared_ptr&lt; const <a class="el" href="structmodule_1_1extension_1_1provider_1_1Provider.html">provider::Provider</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates options for each provider in a provider group specified by the passed type. </p>
<p>This function will check each provider in the group and make an option for it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of task we are trying to run </td></tr>
    <tr><td class="paramname">authority</td><td>the task that we are using as our authority token for permission checks </td></tr>
    <tr><td class="paramname">visited</td><td>the set of providers that have already been visited to prevent loops</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of possible solution options for the provider group of the passed type </dd></dl>

</div>
</div>
<a id="af1d65a6d37112d4b1a8bcb930780b656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d65a6d37112d4b1a8bcb930780b656">&#9670;&nbsp;</a></span>solve_provider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution_1_1Option.html">Director::Solution::Option</a> module::extension::Director::solve_provider </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1provider_1_1Provider.html">provider::Provider</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>provider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>authority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::shared_ptr&lt; const <a class="el" href="structmodule_1_1extension_1_1provider_1_1Provider.html">provider::Provider</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the passed provider as an option for a solution along with its requirements. </p>
<p>It will recursively find Solutions for each of the requirements of the provider including its unmet when conditions and needs relationships.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">provider</td><td>the provider that we are trying to find a solution for </td></tr>
    <tr><td class="paramname">authority</td><td>the task that we are using as our authority token for permission checks </td></tr>
    <tr><td class="paramname">visited</td><td>the set of providers that have already been visited to prevent loops</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a36b5c76a054ee519a189085c85a4a4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b5c76a054ee519a189085c85a4a4c8">&#9670;&nbsp;</a></span>solve_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Director::Solution</a> module::extension::Director::solve_task </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a solution for a given task. </p>
<p>It will start with the provider group for the given task and recursively work its way down to find all possible solutions. It will use the passed task as an authority token for the permission checks on providers that it needs to run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task we are finding solutions for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of possible solution options for this task </dd></dl>

</div>
</div>
<a id="a92552817ea426f29109e51e468c951c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92552817ea426f29109e51e468c951c7">&#9670;&nbsp;</a></span>solve_when()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Director::Solution</a> module::extension::Director::solve_when </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmodule_1_1extension_1_1provider_1_1Provider_1_1WhenCondition.html">provider::Provider::WhenCondition</a> &amp;&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1BehaviourTask.html">extension::behaviour::commands::BehaviourTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>authority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::shared_ptr&lt; const <a class="el" href="structmodule_1_1extension_1_1provider_1_1Provider.html">provider::Provider</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the providers that can cause the passed when condition to be met. </p>
<p>It will then recursively find Solutions for each of the requirements of the provider potentially including more when conditions that need to be met. The final solution for a task could end up with several steps removed from the original task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">when</td><td>the when condition we want to meet by finding causings that will allow a provider to run </td></tr>
    <tr><td class="paramname">authority</td><td>the task that we are using as our authority token for permission checks </td></tr>
    <tr><td class="paramname">visited</td><td>the set of providers that have already been visited to prevent loops</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of providers that when run can meet the provided when condition </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>module/extension/Director/src/<a class="el" href="Director_8hpp_source.html">Director.hpp</a></li>
<li>module/extension/Director/src/director/challenge_priority.cpp</li>
<li>module/extension/Director/src/director/reevaluate_queue.cpp</li>
<li>module/extension/Director/src/director/remove_task.cpp</li>
<li>module/extension/Director/src/director/run_task_pack.cpp</li>
<li>module/extension/Director/src/director/solve.cpp</li>
<li>module/extension/Director/src/Director.cpp</li>
<li>module/extension/Director/src/information/get_task_data.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>module</b></li><li class="navelem"><b>extension</b></li><li class="navelem"><a class="el" href="classmodule_1_1extension_1_1Director.html">Director</a></li>
    <li class="footer">Generated on Sat Oct 8 2022 23:55:52 for NUbots by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
