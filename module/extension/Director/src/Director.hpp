/*
 * This file is part of the NUbots Codebase.
 *
 * The NUbots Codebase is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * The NUbots Codebase is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with the NUbots Codebase.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021 NUbots <nubots@nubots.net>
 */
#ifndef MODULE_EXTENSION_DIRECTOR_HPP
#define MODULE_EXTENSION_DIRECTOR_HPP

#include <memory>
#include <nuclear>
#include <typeindex>
#include <vector>

#include "provider/ProviderGroup.hpp"

#include "extension/Behaviour.hpp"

namespace module::extension {

    class Director : public NUClear::Reactor {
    public:
        /// A task list is just a list of tasks
        using TaskList = std::vector<std::shared_ptr<const ::extension::behaviour::commands::DirectorTask>>;

    private:
        /**
         * Adds a Provider for a type
         *
         * @param p the ProvidesReaction object that was generated by the Behaviour extension
         *
         * @throws std::runtime_error when there is more than one Provides in an on statement
         */
        void add_provider(const ::extension::behaviour::commands::ProvidesReaction& provides);

        /**
         * Removes a Provider for a type
         *
         * @param id the id of the reaction we want to remove the Provider for
         *
         * @throws std::runtime_error when the reaction does not provide anything
         */
        void remove_provider(const uint64_t& id);

        /**
         * Add a when condition to an existing Provider
         *
         * @param when the description of the When expression from the Behaviour extension
         */
        void add_when(const ::extension::behaviour::commands::WhenExpression& when);

        /**
         * Add a causing condition to an existing Provider
         *
         * @param causing the description of the Causing expression from the behaviour extension
         */
        void add_causing(const ::extension::behaviour::commands::CausingExpression& causing);

        /**
         * Compares the priorities of two director tasks and returns true if the challenger has priority over the
         * incumbent.
         *
         * The function requires that the challenger's precendence is strictly greater than the incumbent's.
         * This ensures that we don't change tasks unnecessarily when the priority is equal.
         *
         * @param incumbent     the task to compare which is currently the active running task
         * @param challenger    the task to compare which wants to run but is not currently running
         *
         * @return true     if the challenger has strictly higher priority than the incumbent
         * @return false    if the incumbent task has equal or higher priority
         *
         * @throws std::runtime_error if the director's provider ancestry is broken
         */
        [[nodiscard]] bool challenge_priority(
            const std::shared_ptr<const ::extension::behaviour::commands::DirectorTask>& incumbent,
            const std::shared_ptr<const ::extension::behaviour::commands::DirectorTask>& challenger);

        /**
         * Remove the provided task from the Director.
         *
         * This function also deals with all the consequences of removing the task including looking to see if a queued
         * task can now be run.
         *
         * @param task the task to remove from the Director
         */
        void remove_task(const std::shared_ptr<const ::extension::behaviour::commands::DirectorTask>& task);

        /**
         * Reevaluates all of the tasks that are queued to execute on a provider group.
         *
         * Each of the tasks in the queue are waiting to use this provider group but cannot for some reason or another.
         * In order to determine if they can now run on the queue we need to look at each queued task and inspect if the
         * provider that created them can now run. We do this by simply trying to run them all again.
         *
         * @param group the group whose queue we want to reevaluate
         */
        void reevaluate_queue(provider::ProviderGroup& group);

        /**
         * Looks at all the tasks that are in the pack and determines if they should run, and if so runs them.
         *
         * This function will ensure that if this pack is to be executed it can be executed as a whole. That means that
         * all of the non optional tasks in it are able to run now given the state of the system. If the system is
         * unable to run due to priority or due to a when condition not met it will not run any of the tasks in this
         * pack, but enqueue them on the relevant providers.
         *
         * In the event that `When` conditions needs to be met by this pack and it has sufficient priority, it may also
         * place this provider group into a "PROXYING" state whereby it forces another provider group into a state where
         * it will make the system reach the causing it requires.
         *
         * @param pack the task pack that represents the queued tasks
         */
        void run_task_pack(const TaskList& pack);

    public:
        /// Called by the powerplant to build and setup the Director reactor.
        explicit Director(std::unique_ptr<NUClear::Environment> environment);

    private:
        /// A list of Provider groups
        std::map<std::type_index, provider::ProviderGroup> groups;
        /// Maps reaction_id to the Provider which implements it
        std::map<uint64_t, std::shared_ptr<provider::Provider>> providers;

        /// A list of reaction_task_ids to director_task objects, once the Provider has finished running it will emit
        /// all these as a pack so that the director can work out when Providers change which subtasks they emit
        std::multimap<uint64_t, std::shared_ptr<const ::extension::behaviour::commands::DirectorTask>> pack_builder;
    };

}  // namespace module::extension

#endif  // MODULE_EXTENSION_DIRECTOR_HPP
